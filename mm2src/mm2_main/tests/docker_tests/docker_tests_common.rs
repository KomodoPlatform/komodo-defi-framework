pub use common::{block_on, now_ms, now_sec, wait_until_ms, wait_until_sec, DEX_FEE_ADDR_RAW_PUBKEY};
pub use mm2_number::MmNumber;
use mm2_rpc::data::legacy::BalanceResponse;
pub use mm2_test_helpers::for_tests::{check_my_swap_status, check_recent_swaps, enable_eth_coin, enable_native,
                                      enable_native_bch, erc20_dev_conf, eth_dev_conf, eth_sepolia_conf,
                                      jst_sepolia_conf, mm_dump, wait_check_stats_swap_status, MarketMakerIt,
                                      MAKER_ERROR_EVENTS, MAKER_SUCCESS_EVENTS, TAKER_ERROR_EVENTS,
                                      TAKER_SUCCESS_EVENTS};

use super::eth_docker_tests::{erc20_contract_checksum, fill_eth, fill_eth_erc20_with_private_key, geth_account,
                              swap_contract};
use bitcrypto::{dhash160, ChecksumType};
use chain::TransactionOutput;
use coins::eth::addr_from_raw_pubkey;
use coins::qrc20::rpc_clients::for_tests::Qrc20NativeWalletOps;
use coins::qrc20::{qrc20_coin_with_priv_key, Qrc20ActivationParams, Qrc20Coin};
use coins::utxo::bch::{bch_coin_with_priv_key, BchActivationRequest, BchCoin};
use coins::utxo::qtum::{qtum_coin_with_priv_key, QtumBasedCoin, QtumCoin};
use coins::utxo::rpc_clients::{NativeClient, UtxoRpcClientEnum, UtxoRpcClientOps};
use coins::utxo::slp::{slp_genesis_output, SlpOutput, SlpToken};
use coins::utxo::utxo_common::send_outputs_from_my_address;
use coins::utxo::utxo_standard::{utxo_standard_coin_with_priv_key, UtxoStandardCoin};
use coins::utxo::{coin_daemon_data_dir, sat_from_big_decimal, zcash_params_path, UtxoActivationParams,
                  UtxoAddressFormat, UtxoCoinFields, UtxoCommonOps};
use coins::{ConfirmPaymentInput, MarketCoinOps, Transaction};
use crypto::privkey::key_pair_from_seed;
use crypto::Secp256k1Secret;
use ethabi::Token;
use ethereum_types::{H160 as H160Eth, U256};
use futures::TryFutureExt;
use futures01::Future;
use http::StatusCode;
use keys::{Address, AddressBuilder, AddressHashEnum, AddressPrefix, KeyPair, NetworkAddressPrefixes,
           NetworkPrefix as CashAddrPrefix};
use mm2_core::mm_ctx::{MmArc, MmCtxBuilder};
use mm2_number::BigDecimal;
use mm2_test_helpers::get_passphrase;
use mm2_test_helpers::structs::TransactionDetails;
use primitives::hash::{H160, H256};
use script::Builder;
use secp256k1::Secp256k1;
pub use secp256k1::{PublicKey, SecretKey};
use serde_json::{self as json, Value as Json};
use std::process::{Command, Stdio};
pub use std::{env, thread};
use std::{path::PathBuf, str::FromStr, sync::Mutex, time::Duration};
use testcontainers::{clients::Cli, core::WaitFor, Container, GenericImage, RunnableImage};
use web3::types::{Address as EthAddress, BlockId, BlockNumber, TransactionRequest};
use web3::{transports::Http, Web3};

lazy_static! {
    static ref MY_COIN_LOCK: Mutex<()> = Mutex::new(());
    static ref MY_COIN1_LOCK: Mutex<()> = Mutex::new(());
    static ref QTUM_LOCK: Mutex<()> = Mutex::new(());
    static ref FOR_SLP_LOCK: Mutex<()> = Mutex::new(());
    pub static ref SLP_TOKEN_ID: Mutex<H256> = Mutex::new(H256::default());
    // Private keys supplied with 1000 SLP tokens on tests initialization.
    // Due to the SLP protocol limitations only 19 outputs (18 + change) can be sent in one transaction, which is sufficient for now though.
    // Supply more privkeys when 18 will be not enough.
    pub static ref SLP_TOKEN_OWNERS: Mutex<Vec<[u8; 32]>> = Mutex::new(Vec::with_capacity(18));
    pub static ref MM_CTX: MmArc = MmCtxBuilder::new().into_mm_arc();
    /// We need a second `MmCtx` instance when we use the same private keys for Maker and Taker across various tests.
    /// When enabling coins for both Maker and Taker, two distinct coin instances are created.
    /// This means that different instances of the same coin should have separate global nonce locks.
    /// Utilizing different `MmCtx` instances allows us to assign Maker and Taker coins to separate `CoinsCtx`.
    /// This approach addresses the `replacement transaction` issue, which occurs when different transactions share the same nonce.
    pub static ref MM_CTX1: MmArc = MmCtxBuilder::new().into_mm_arc();
    pub static ref GETH_WEB3: Web3<Http> = Web3::new(Http::new(GETH_RPC_URL).unwrap());
    pub static ref SEPOLIA_WEB3: Web3<Http> = Web3::new(Http::new(SEPOLIA_RPC_URL).unwrap());
    // Mutex used to prevent nonce re-usage during funding addresses used in tests
    pub static ref GETH_NONCE_LOCK: Mutex<()> = Mutex::new(());
    pub static ref SEPOLIA_NONCE_LOCK: Mutex<()> = Mutex::new(());
}

pub static mut QICK_TOKEN_ADDRESS: Option<H160Eth> = None;
pub static mut QORTY_TOKEN_ADDRESS: Option<H160Eth> = None;
pub static mut QRC20_SWAP_CONTRACT_ADDRESS: Option<H160Eth> = None;
pub static mut QTUM_CONF_PATH: Option<PathBuf> = None;
/// The account supplied with ETH on Geth dev node creation
pub static mut GETH_ACCOUNT: H160Eth = H160Eth::zero();
/// ERC20 token address on Geth dev node
pub static mut GETH_ERC20_CONTRACT: H160Eth = H160Eth::zero();
/// Swap contract address on Geth dev node
pub static mut GETH_SWAP_CONTRACT: H160Eth = H160Eth::zero();
/// Maker Swap V2 contract address on Geth dev node
pub static mut GETH_MAKER_SWAP_V2: H160Eth = H160Eth::zero();
/// Taker Swap V2 contract address on Geth dev node
pub static mut GETH_TAKER_SWAP_V2: H160Eth = H160Eth::zero();
/// Swap contract (with watchers support) address on Geth dev node
pub static mut GETH_WATCHERS_SWAP_CONTRACT: H160Eth = H160Eth::zero();
/// ERC721 token address on Geth dev node
pub static mut GETH_ERC721_CONTRACT: H160Eth = H160Eth::zero();
/// ERC1155 token address on Geth dev node
pub static mut GETH_ERC1155_CONTRACT: H160Eth = H160Eth::zero();
/// Nft Swap contract address on Geth dev node
pub static mut GETH_NFT_SWAP_CONTRACT: H160Eth = H160Eth::zero();
/// NFT Maker Swap V2 contract address on Geth dev node
pub static mut GETH_NFT_MAKER_SWAP_V2: H160Eth = H160Eth::zero();
/// NFT Maker Swap V2 contract address on Sepolia testnet
pub static mut SEPOLIA_ETOMIC_MAKER_NFT_SWAP_V2: H160Eth = H160Eth::zero();
/// ERC721 token address on Sepolia testnet
pub static mut SEPOLIA_ERC721_CONTRACT: H160Eth = H160Eth::zero();
/// ERC1155 token address on Sepolia testnet
pub static mut SEPOLIA_ERC1155_CONTRACT: H160Eth = H160Eth::zero();
pub static GETH_RPC_URL: &str = "http://127.0.0.1:8545";
pub static SEPOLIA_RPC_URL: &str = "https://ethereum-sepolia-rpc.publicnode.com";

pub const UTXO_ASSET_DOCKER_IMAGE: &str = "docker.io/artempikulin/testblockchain";
pub const UTXO_ASSET_DOCKER_IMAGE_WITH_TAG: &str = "docker.io/artempikulin/testblockchain:multiarch";
pub const GETH_DOCKER_IMAGE: &str = "docker.io/ethereum/client-go";
pub const GETH_DOCKER_IMAGE_WITH_TAG: &str = "docker.io/ethereum/client-go:stable";

pub const NUCLEUS_IMAGE: &str = "docker.io/komodoofficial/nucleusd";
pub const ATOM_IMAGE: &str = "docker.io/komodoofficial/gaiad";
pub const IBC_RELAYER_IMAGE: &str = "docker.io/komodoofficial/ibc-relayer";

pub const QTUM_ADDRESS_LABEL: &str = "MM2_ADDRESS_LABEL";

/// ERC721_TEST_TOKEN has additional mint function
pub const ERC721_TEST_ABI: &str = include_str!("../../../mm2_test_helpers/dummy_files/erc721_test_abi.json");
/// ERC1155_TEST_TOKEN has additional mint function
pub const ERC1155_TEST_ABI: &str = include_str!("../../../mm2_test_helpers/dummy_files/erc1155_test_abi.json");

/// Ticker of MYCOIN dockerized blockchain.
pub const MYCOIN: &str = "MYCOIN";
/// Ticker of MYCOIN1 dockerized blockchain.
pub const MYCOIN1: &str = "MYCOIN1";

pub const ERC20_TOKEN_BYTES: &str = include_str!("../../../mm2_test_helpers/contract_bytes/erc20_token_bytes");
pub const SWAP_CONTRACT_BYTES: &str = include_str!("../../../mm2_test_helpers/contract_bytes/swap_contract_bytes");
pub const WATCHERS_SWAP_CONTRACT_BYTES: &str =
    include_str!("../../../mm2_test_helpers/contract_bytes/watchers_swap_contract_bytes");
pub const ERC721_TEST_TOKEN_BYTES: &str =
    include_str!("../../../mm2_test_helpers/contract_bytes/erc721_test_token_bytes");
pub const ERC1155_TEST_TOKEN_BYTES: &str =
    include_str!("../../../mm2_test_helpers/contract_bytes/erc1155_test_token_bytes");
pub const NFT_SWAP_CONTRACT_BYTES: &str =
    include_str!("../../../mm2_test_helpers/contract_bytes/nft_swap_contract_bytes");
/// https://github.com/KomodoPlatform/etomic-swap/blob/006e6fd52334530f23624a2139d0eb5299c4cd10/contracts/EtomicSwapMakerNftV2Test.sol
pub const NFT_MAKER_SWAP_V2_BYTES: &str =
    include_str!("../../../mm2_test_helpers/contract_bytes/nft_maker_swap_v2_bytes");
/// https://github.com/KomodoPlatform/etomic-swap/blob/5e15641cbf41766cd5b37b4d71842c270773f788/contracts/EtomicSwapMakerNftV2.sol
pub const MAKER_SWAP_V2_BYTES: &str = include_str!("../../../mm2_test_helpers/contract_bytes/maker_swap_v2_bytes");
/// https://github.com/KomodoPlatform/etomic-swap/blob/5e15641cbf41766cd5b37b4d71842c270773f788/contracts/EtomicSwapTakerV2.sol
pub const TAKER_SWAP_V2_BYTES: &str = include_str!("../../../mm2_test_helpers/contract_bytes/taker_swap_v2_bytes");
pub const NFT_MAKER_SWAP_V2_BYTES: &str = "6080604052348015600e575f80fd5b50612ffd8061001c5f395ff3fe608060405234801561000f575f80fd5b50600436106100a7575f3560e01c8063b27e46fb1161006f578063b27e46fb1461015f578063bc197c811461017b578063c8d9009b146101ab578063c92cd12d146101c7578063efccb9eb146101e3578063f23a6e6114610215576100a7565b806301ffc9a7146100ab57806305ec158d146100db5780630f235fce146100f7578063150b7a02146101135780636e6bf6d214610143575b5f80fd5b6100c560048036038101906100c09190611ebc565b610245565b6040516100d29190611f01565b60405180910390f35b6100f560048036038101906100f09190611fda565b610326565b005b610111600480360381019061010c9190612077565b6105e6565b005b61012d60048036038101906101289190612161565b6108a0565b60405161013a91906121f4565b60405180910390f35b61015d60048036038101906101589190612077565b610cef565b005b61017960048036038101906101749190611fda565b610faa565b005b61019560048036038101906101909190612262565b611269565b6040516101a291906121f4565b60405180910390f35b6101c560048036038101906101c09190612077565b6112a5565b005b6101e160048036038101906101dc9190611fda565b6115ce565b005b6101fd60048036038101906101f89190612339565b6118fc565b60405161020c9392919061242f565b60405180910390f35b61022f600480360381019061022a9190612464565b611948565b60405161023c91906121f4565b60405180910390f35b5f7f4e2312e0000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148061030f57507f150b7a02000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8061031f575061031e82611ddc565b5b9050919050565b6001600381111561033a576103396123bc565b5b5f808981526020019081526020015f205f0160189054906101000a900460ff16600381111561036c5761036b6123bc565b5b146103ac576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103a39061257a565b60405180910390fd5b5f600387336002896040516020016103c491906125b8565b6040516020818303038152906040526040516103e09190612624565b602060405180830381855afa1580156103fb573d5f803e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061041e919061264e565b8888888860405160200161043897969594939291906126de565b6040516020818303038152906040526040516104549190612624565b602060405180830381855afa15801561046f573d5f803e3d5ffd5b5050506040515160601b90505f808981526020019081526020015f205f015f9054906101000a900460601b6bffffffffffffffffffffffff1916816bffffffffffffffffffffffff1916146104f9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104f0906127a8565b60405180910390fd5b60035f808a81526020019081526020015f205f0160186101000a81548160ff0219169083600381111561052f5761052e6123bc565b5b02179055507fac509cdcc7ddb189f81fff6f4824f5c95076e64c3bdce542c50feaa6779afd738860405161056391906127d5565b60405180910390a15f8490508073ffffffffffffffffffffffffffffffffffffffff1663f242432a303387876040518563ffffffff1660e01b81526004016105ae949392919061283f565b5f604051808303815f87803b1580156105c5575f80fd5b505af11580156105d7573d5f803e3d5ffd5b50505050505050505050505050565b600160038111156105fa576105f96123bc565b5b5f808881526020019081526020015f205f0160189054906101000a900460ff16600381111561062c5761062b6123bc565b5b1461066c576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106639061257a565b60405180910390fd5b5f600386338787878760405160200161068a96959493929190612895565b6040516020818303038152906040526040516106a69190612624565b602060405180830381855afa1580156106c1573d5f803e3d5ffd5b5050506040515160601b90505f808881526020019081526020015f205f015f9054906101000a900460601b6bffffffffffffffffffffffff1916816bffffffffffffffffffffffff19161461074b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610742906127a8565b60405180910390fd5b5f808881526020019081526020015f205f0160149054906101000a900463ffffffff1663ffffffff164210156107b6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016107ad90612974565b60405180910390fd5b60035f808981526020019081526020015f205f0160186101000a81548160ff021916908360038111156107ec576107eb6123bc565b5b02179055507f5dedc4f52b757d9112d09ca0b2f022927104d54e3f54da091587e8ad192190728760405161082091906127d5565b60405180910390a15f8390508073ffffffffffffffffffffffffffffffffffffffff166342842e0e3033866040518463ffffffff1660e01b815260040161086993929190612992565b5f604051808303815f87803b158015610880575f80fd5b505af1158015610892573d5f803e3d5ffd5b505050505050505050505050565b5f8083838101906108b19190612b1a565b90505f60038111156108c6576108c56123bc565b5b5f80835f015181526020019081526020015f205f0160189054906101000a900460ff1660038111156108fb576108fa6123bc565b5b1461093b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161093290612bb5565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff16036109ad576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109a490612c1d565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff1603610a1f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a1690612c85565b60405180910390fd5b806040015173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610a91576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a8890612d13565b60405180910390fd5b8573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff1614610aff576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610af690612d7b565b60405180910390fd5b610b0c8160200151611e45565b15610b4c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b4390612de3565b60405180910390fd5b5f60038260200151888460600151856080015186604001518b604051602001610b7a96959493929190612895565b604051602081830303815290604052604051610b969190612624565b602060405180830381855afa158015610bb1573d5f803e3d5ffd5b5050506040515160601b90506040518060600160405280826bffffffffffffffffffffffff191681526020018360a0015163ffffffff16815260200160016003811115610c0157610c006123bc565b5b8152505f80845f015181526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908360601c02179055506020820151815f0160146101000a81548163ffffffff021916908363ffffffff1602179055506040820151815f0160186101000a81548160ff02191690836003811115610c9857610c976123bc565b5b02179055509050507ff1dc11bbb6d7542c4267ecf1d370ff4c7092518633ecae9939e8488f4e53d2ad825f0151604051610cd291906127d5565b60405180910390a163150b7a0260e01b9250505095945050505050565b60016003811115610d0357610d026123bc565b5b5f808881526020019081526020015f205f0160189054906101000a900460ff166003811115610d3557610d346123bc565b5b14610d75576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d6c9061257a565b60405180910390fd5b5f60038633600288604051602001610d8d91906125b8565b604051602081830303815290604052604051610da99190612624565b602060405180830381855afa158015610dc4573d5f803e3d5ffd5b5050506040513d601f19601f82011682018060405250810190610de7919061264e565b878787604051602001610dff96959493929190612895565b604051602081830303815290604052604051610e1b9190612624565b602060405180830381855afa158015610e36573d5f803e3d5ffd5b5050506040515160601b90505f808881526020019081526020015f205f015f9054906101000a900460601b6bffffffffffffffffffffffff1916816bffffffffffffffffffffffff191614610ec0576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610eb7906127a8565b60405180910390fd5b60035f808981526020019081526020015f205f0160186101000a81548160ff02191690836003811115610ef657610ef56123bc565b5b02179055507fac509cdcc7ddb189f81fff6f4824f5c95076e64c3bdce542c50feaa6779afd7387604051610f2a91906127d5565b60405180910390a15f8390508073ffffffffffffffffffffffffffffffffffffffff166342842e0e3033866040518463ffffffff1660e01b8152600401610f7393929190612992565b5f604051808303815f87803b158015610f8a575f80fd5b505af1158015610f9c573d5f803e3d5ffd5b505050505050505050505050565b60016003811115610fbe57610fbd6123bc565b5b5f808981526020019081526020015f205f0160189054906101000a900460ff166003811115610ff057610fef6123bc565b5b14611030576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110279061257a565b60405180910390fd5b5f60038733888888888860405160200161105097969594939291906126de565b60405160208183030381529060405260405161106c9190612624565b602060405180830381855afa158015611087573d5f803e3d5ffd5b5050506040515160601b90505f808981526020019081526020015f205f015f9054906101000a900460601b6bffffffffffffffffffffffff1916816bffffffffffffffffffffffff191614611111576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611108906127a8565b60405180910390fd5b5f808981526020019081526020015f205f0160149054906101000a900463ffffffff1663ffffffff1642101561117c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161117390612974565b60405180910390fd5b60035f808a81526020019081526020015f205f0160186101000a81548160ff021916908360038111156111b2576111b16123bc565b5b02179055507f5dedc4f52b757d9112d09ca0b2f022927104d54e3f54da091587e8ad19219072886040516111e691906127d5565b60405180910390a15f8490508073ffffffffffffffffffffffffffffffffffffffff1663f242432a303387876040518563ffffffff1660e01b8152600401611231949392919061283f565b5f604051808303815f87803b158015611248575f80fd5b505af115801561125a573d5f803e3d5ffd5b50505050505050505050505050565b5f6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161129c90612e4b565b60405180910390fd5b600160038111156112b9576112b86123bc565b5b5f808881526020019081526020015f205f0160189054906101000a900460ff1660038111156112eb576112ea6123bc565b5b1461132b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113229061257a565b60405180910390fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611399576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161139090612eb3565b60405180910390fd5b5f60033387876002886040516020016113b291906125b8565b6040516020818303038152906040526040516113ce9190612624565b602060405180830381855afa1580156113e9573d5f803e3d5ffd5b5050506040513d601f19601f8201168201806040525081019061140c919061264e565b878760405160200161142396959493929190612895565b60405160208183030381529060405260405161143f9190612624565b602060405180830381855afa15801561145a573d5f803e3d5ffd5b5050506040515160601b90505f808881526020019081526020015f205f015f9054906101000a900460601b6bffffffffffffffffffffffff1916816bffffffffffffffffffffffff1916146114e4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114db906127a8565b60405180910390fd5b60025f808981526020019081526020015f205f0160186101000a81548160ff0219169083600381111561151a576115196123bc565b5b02179055507fad62ed075fe8969df63026f45152d6e996a0697a736a8de92ee85ae9c9958cf08760405161154e91906127d5565b60405180910390a15f8390508073ffffffffffffffffffffffffffffffffffffffff166342842e0e3033866040518463ffffffff1660e01b815260040161159793929190612992565b5f604051808303815f87803b1580156115ae575f80fd5b505af11580156115c0573d5f803e3d5ffd5b505050505050505050505050565b600160038111156115e2576115e16123bc565b5b5f808981526020019081526020015f205f0160189054906101000a900460ff166003811115611614576116136123bc565b5b14611654576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161164b9061257a565b60405180910390fd5b3273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146116c2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016116b990612eb3565b60405180910390fd5b5f60033388886002896040516020016116db91906125b8565b6040516020818303038152906040526040516116f79190612624565b602060405180830381855afa158015611712573d5f803e3d5ffd5b5050506040513d601f19601f82011682018060405250810190611735919061264e565b88888860405160200161174e97969594939291906126de565b60405160208183030381529060405260405161176a9190612624565b602060405180830381855afa158015611785573d5f803e3d5ffd5b5050506040515160601b90505f808981526020019081526020015f205f015f9054906101000a900460601b6bffffffffffffffffffffffff1916816bffffffffffffffffffffffff19161461180f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611806906127a8565b60405180910390fd5b60025f808a81526020019081526020015f205f0160186101000a81548160ff02191690836003811115611845576118446123bc565b5b02179055507fad62ed075fe8969df63026f45152d6e996a0697a736a8de92ee85ae9c9958cf08860405161187991906127d5565b60405180910390a15f8490508073ffffffffffffffffffffffffffffffffffffffff1663f242432a303387876040518563ffffffff1660e01b81526004016118c4949392919061283f565b5f604051808303815f87803b1580156118db575f80fd5b505af11580156118ed573d5f803e3d5ffd5b50505050505050505050505050565b5f602052805f5260405f205f91509050805f015f9054906101000a900460601b90805f0160149054906101000a900463ffffffff1690805f0160189054906101000a900460ff16905083565b5f8083838101906119599190612b1a565b90505f600381111561196e5761196d6123bc565b5b5f80835f015181526020019081526020015f205f0160189054906101000a900460ff1660038111156119a3576119a26123bc565b5b146119e3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016119da90612f41565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff16816020015173ffffffffffffffffffffffffffffffffffffffff1603611a55576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a4c90612c1d565b60405180910390fd5b5f73ffffffffffffffffffffffffffffffffffffffff16816040015173ffffffffffffffffffffffffffffffffffffffff1603611ac7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611abe90612c85565b60405180910390fd5b806040015173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611b39576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b3090612d13565b60405180910390fd5b8673ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff1614611ba7576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b9e90612d7b565b60405180910390fd5b5f8511611be9576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611be090612fa9565b60405180910390fd5b611bf68160200151611e45565b15611c36576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c2d90612de3565b60405180910390fd5b5f60038260200151898460600151856080015186604001518c8c604051602001611c6697969594939291906126de565b604051602081830303815290604052604051611c829190612624565b602060405180830381855afa158015611c9d573d5f803e3d5ffd5b5050506040515160601b90506040518060600160405280826bffffffffffffffffffffffff191681526020018360a0015163ffffffff16815260200160016003811115611ced57611cec6123bc565b5b8152505f80845f015181526020019081526020015f205f820151815f015f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908360601c02179055506020820151815f0160146101000a81548163ffffffff021916908363ffffffff1602179055506040820151815f0160186101000a81548160ff02191690836003811115611d8457611d836123bc565b5b02179055509050507ff1dc11bbb6d7542c4267ecf1d370ff4c7092518633ecae9939e8488f4e53d2ad825f0151604051611dbe91906127d5565b60405180910390a163f23a6e6160e01b925050509695505050505050565b5f7f01ffc9a7000000000000000000000000000000000000000000000000000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916149050919050565b5f80823b90505f8111915050919050565b5f604051905090565b5f80fd5b5f80fd5b5f7fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b611e9b81611e67565b8114611ea5575f80fd5b50565b5f81359050611eb681611e92565b92915050565b5f60208284031215611ed157611ed0611e5f565b5b5f611ede84828501611ea8565b91505092915050565b5f8115159050919050565b611efb81611ee7565b82525050565b5f602082019050611f145f830184611ef2565b92915050565b5f819050919050565b611f2c81611f1a565b8114611f36575f80fd5b50565b5f81359050611f4781611f23565b92915050565b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f611f7682611f4d565b9050919050565b611f8681611f6c565b8114611f90575f80fd5b50565b5f81359050611fa181611f7d565b92915050565b5f819050919050565b611fb981611fa7565b8114611fc3575f80fd5b50565b5f81359050611fd481611fb0565b92915050565b5f805f805f805f60e0888a031215611ff557611ff4611e5f565b5b5f6120028a828b01611f39565b97505060206120138a828b01611f93565b96505060406120248a828b01611f39565b95505060606120358a828b01611f39565b94505060806120468a828b01611f93565b93505060a06120578a828b01611fc6565b92505060c06120688a828b01611fc6565b91505092959891949750929550565b5f805f805f8060c0878903121561209157612090611e5f565b5b5f61209e89828a01611f39565b96505060206120af89828a01611f93565b95505060406120c089828a01611f39565b94505060606120d189828a01611f39565b93505060806120e289828a01611f93565b92505060a06120f389828a01611fc6565b9150509295509295509295565b5f80fd5b5f80fd5b5f80fd5b5f8083601f84011261212157612120612100565b5b8235905067ffffffffffffffff81111561213e5761213d612104565b5b60208301915083600182028301111561215a57612159612108565b5b9250929050565b5f805f805f6080868803121561217a57612179611e5f565b5b5f61218788828901611f93565b955050602061219888828901611f93565b94505060406121a988828901611fc6565b935050606086013567ffffffffffffffff8111156121ca576121c9611e63565b5b6121d68882890161210c565b92509250509295509295909350565b6121ee81611e67565b82525050565b5f6020820190506122075f8301846121e5565b92915050565b5f8083601f84011261222257612221612100565b5b8235905067ffffffffffffffff81111561223f5761223e612104565b5b60208301915083602082028301111561225b5761225a612108565b5b9250929050565b5f805f805f805f8060a0898b03121561227e5761227d611e5f565b5b5f61228b8b828c01611f93565b985050602061229c8b828c01611f93565b975050604089013567ffffffffffffffff8111156122bd576122bc611e63565b5b6122c98b828c0161220d565b9650965050606089013567ffffffffffffffff8111156122ec576122eb611e63565b5b6122f88b828c0161220d565b9450945050608089013567ffffffffffffffff81111561231b5761231a611e63565b5b6123278b828c0161210c565b92509250509295985092959890939650565b5f6020828403121561234e5761234d611e5f565b5b5f61235b84828501611f39565b91505092915050565b5f7fffffffffffffffffffffffffffffffffffffffff00000000000000000000000082169050919050565b61239881612364565b82525050565b5f63ffffffff82169050919050565b6123b68161239e565b82525050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52602160045260245ffd5b600481106123fa576123f96123bc565b5b50565b5f81905061240a826123e9565b919050565b5f612419826123fd565b9050919050565b6124298161240f565b82525050565b5f6060820190506124425f83018661238f565b61244f60208301856123ad565b61245c6040830184612420565b949350505050565b5f805f805f8060a0878903121561247e5761247d611e5f565b5b5f61248b89828a01611f93565b965050602061249c89828a01611f93565b95505060406124ad89828a01611fc6565b94505060606124be89828a01611fc6565b935050608087013567ffffffffffffffff8111156124df576124de611e63565b5b6124eb89828a0161210c565b92509250509295509295509295565b5f82825260208201905092915050565b7f496e76616c6964207061796d656e742073746174652e204d75737420626520505f8201527f61796d656e7453656e7400000000000000000000000000000000000000000000602082015250565b5f612564602a836124fa565b915061256f8261250a565b604082019050919050565b5f6020820190508181035f83015261259181612558565b9050919050565b5f819050919050565b6125b26125ad82611f1a565b612598565b82525050565b5f6125c382846125a1565b60208201915081905092915050565b5f81519050919050565b5f81905092915050565b8281835e5f83830152505050565b5f6125fe826125d2565b61260881856125dc565b93506126188185602086016125e6565b80840191505092915050565b5f61262f82846125f4565b915081905092915050565b5f8151905061264881611f23565b92915050565b5f6020828403121561266357612662611e5f565b5b5f6126708482850161263a565b91505092915050565b5f8160601b9050919050565b5f61268f82612679565b9050919050565b5f6126a082612685565b9050919050565b6126b86126b382611f6c565b612696565b82525050565b5f819050919050565b6126d86126d382611fa7565b6126be565b82525050565b5f6126e9828a6126a7565b6014820191506126f982896126a7565b60148201915061270982886125a1565b60208201915061271982876125a1565b60208201915061272982866126a7565b60148201915061273982856126c7565b60208201915061274982846126c7565b60208201915081905098975050505050505050565b7f496e76616c6964207061796d656e7448617368000000000000000000000000005f82015250565b5f6127926013836124fa565b915061279d8261275e565b602082019050919050565b5f6020820190508181035f8301526127bf81612786565b9050919050565b6127cf81611f1a565b82525050565b5f6020820190506127e85f8301846127c6565b92915050565b6127f781611f6c565b82525050565b61280681611fa7565b82525050565b5f82825260208201905092915050565b50565b5f61282a5f8361280c565b91506128358261281c565b5f82019050919050565b5f60a0820190506128525f8301876127ee565b61285f60208301866127ee565b61286c60408301856127fd565b61287960608301846127fd565b818103608083015261288a8161281f565b905095945050505050565b5f6128a082896126a7565b6014820191506128b082886126a7565b6014820191506128c082876125a1565b6020820191506128d082866125a1565b6020820191506128e082856126a7565b6014820191506128f082846126c7565b602082019150819050979650505050505050565b7f43757272656e742074696d657374616d70206469646e277420657863656564205f8201527f7061796d656e7420726566756e64206c6f636b2074696d650000000000000000602082015250565b5f61295e6038836124fa565b915061296982612904565b604082019050919050565b5f6020820190508181035f83015261298b81612952565b9050919050565b5f6060820190506129a55f8301866127ee565b6129b260208301856127ee565b6129bf60408301846127fd565b949350505050565b5f80fd5b5f601f19601f8301169050919050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b612a11826129cb565b810181811067ffffffffffffffff82111715612a3057612a2f6129db565b5b80604052505050565b5f612a42611e56565b9050612a4e8282612a08565b919050565b612a5c8161239e565b8114612a66575f80fd5b50565b5f81359050612a7781612a53565b92915050565b5f60c08284031215612a9257612a916129c7565b5b612a9c60c0612a39565b90505f612aab84828501611f39565b5f830152506020612abe84828501611f93565b6020830152506040612ad284828501611f93565b6040830152506060612ae684828501611f39565b6060830152506080612afa84828501611f39565b60808301525060a0612b0e84828501612a69565b60a08301525092915050565b5f60c08284031215612b2f57612b2e611e5f565b5b5f612b3c84828501612a7d565b91505092915050565b7f4d616b657220455243373231207061796d656e74206d75737420626520556e695f8201527f6e697469616c697a656400000000000000000000000000000000000000000000602082015250565b5f612b9f602a836124fa565b9150612baa82612b45565b604082019050919050565b5f6020820190508181035f830152612bcc81612b93565b9050919050565b7f54616b6572206d757374206e6f74206265207a65726f206164647265737300005f82015250565b5f612c07601e836124fa565b9150612c1282612bd3565b602082019050919050565b5f6020820190508181035f830152612c3481612bfb565b9050919050565b7f546f6b656e206d757374206e6f74206265207a65726f206164647265737300005f82015250565b5f612c6f601e836124fa565b9150612c7a82612c3b565b602082019050919050565b5f6020820190508181035f830152612c9c81612c63565b9050919050565b7f546f6b656e206164647265737320646f6573206e6f74206d617463682073656e5f8201527f6465720000000000000000000000000000000000000000000000000000000000602082015250565b5f612cfd6023836124fa565b9150612d0882612ca3565b604082019050919050565b5f6020820190508181035f830152612d2a81612cf1565b9050919050565b7f4f70657261746f72206d757374206265207468652073656e64657200000000005f82015250565b5f612d65601b836124fa565b9150612d7082612d31565b602082019050919050565b5f6020820190508181035f830152612d9281612d59565b9050919050565b7f54616b65722063616e6e6f74206265206120636f6e74726163740000000000005f82015250565b5f612dcd601a836124fa565b9150612dd882612d99565b602082019050919050565b5f6020820190508181035f830152612dfa81612dc1565b9050919050565b7f4261746368207472616e7366657273206e6f7420737570706f727465640000005f82015250565b5f612e35601d836124fa565b9150612e4082612e01565b602082019050919050565b5f6020820190508181035f830152612e6281612e29565b9050919050565b7f43616c6c6572206d75737420626520616e20454f4100000000000000000000005f82015250565b5f612e9d6015836124fa565b9150612ea882612e69565b602082019050919050565b5f6020820190508181035f830152612eca81612e91565b9050919050565b7f4d616b65722045524331313535207061796d656e74206d75737420626520556e5f8201527f696e697469616c697a6564000000000000000000000000000000000000000000602082015250565b5f612f2b602b836124fa565b9150612f3682612ed1565b604082019050919050565b5f6020820190508181035f830152612f5881612f1f565b9050919050565b7f56616c7565206d7573742062652067726561746572207468616e2030000000005f82015250565b5f612f93601c836124fa565b9150612f9e82612f5f565b602082019050919050565b5f6020820190508181035f830152612fc081612f87565b905091905056fea26469706673582212204e239c256ffaf5624f6d55ae2e9f8afd626e0e129a36ff33221d4b2fe58f6b5a64736f6c63430008190033";

pub trait CoinDockerOps {
    fn rpc_client(&self) -> &UtxoRpcClientEnum;

    fn native_client(&self) -> &NativeClient {
        match self.rpc_client() {
            UtxoRpcClientEnum::Native(native) => native,
            _ => panic!("UtxoRpcClientEnum::Native is expected"),
        }
    }

    fn wait_ready(&self, expected_tx_version: i32) {
        let timeout = wait_until_ms(120000);
        loop {
            match self.rpc_client().get_block_count().wait() {
                Ok(n) => {
                    if n > 1 {
                        if let UtxoRpcClientEnum::Native(client) = self.rpc_client() {
                            let hash = client.get_block_hash(n).wait().unwrap();
                            let block = client.get_block(hash).wait().unwrap();
                            let coinbase = client.get_verbose_transaction(&block.tx[0]).wait().unwrap();
                            log!("Coinbase tx {:?} in block {}", coinbase, n);
                            if coinbase.version == expected_tx_version {
                                break;
                            }
                        }
                    }
                },
                Err(e) => log!("{:?}", e),
            }
            assert!(now_ms() < timeout, "Test timed out");
            thread::sleep(Duration::from_secs(1));
        }
    }
}

pub struct UtxoAssetDockerOps {
    #[allow(dead_code)]
    ctx: MmArc,
    coin: UtxoStandardCoin,
}

impl CoinDockerOps for UtxoAssetDockerOps {
    fn rpc_client(&self) -> &UtxoRpcClientEnum { &self.coin.as_ref().rpc_client }
}

impl UtxoAssetDockerOps {
    pub fn from_ticker(ticker: &str) -> UtxoAssetDockerOps {
        let conf = json!({"asset": ticker, "txfee": 1000, "network": "regtest"});
        let req = json!({"method":"enable"});
        let priv_key = Secp256k1Secret::from("809465b17d0a4ddb3e4c69e8f23c2cabad868f51f8bed5c765ad1d6516c3306f");
        let ctx = MmCtxBuilder::new().into_mm_arc();
        let params = UtxoActivationParams::from_legacy_req(&req).unwrap();

        let coin = block_on(utxo_standard_coin_with_priv_key(&ctx, ticker, &conf, &params, priv_key)).unwrap();
        UtxoAssetDockerOps { ctx, coin }
    }
}

pub struct BchDockerOps {
    #[allow(dead_code)]
    ctx: MmArc,
    coin: BchCoin,
}

impl BchDockerOps {
    pub fn from_ticker(ticker: &str) -> BchDockerOps {
        let conf = json!({"asset": ticker,"txfee":1000,"network": "regtest","txversion":4,"overwintered":1});
        let req = json!({"method":"enable", "bchd_urls": [], "allow_slp_unsafe_conf": true});
        let priv_key = Secp256k1Secret::from("809465b17d0a4ddb3e4c69e8f23c2cabad868f51f8bed5c765ad1d6516c3306f");
        let ctx = MmCtxBuilder::new().into_mm_arc();
        let params = BchActivationRequest::from_legacy_req(&req).unwrap();

        let coin = block_on(bch_coin_with_priv_key(
            &ctx,
            ticker,
            &conf,
            params,
            CashAddrPrefix::SlpTest,
            priv_key,
        ))
        .unwrap();
        BchDockerOps { ctx, coin }
    }

    pub fn initialize_slp(&self) {
        fill_address(&self.coin, &self.coin.my_address().unwrap(), 100000.into(), 30);
        let mut slp_privkeys = vec![];

        let slp_genesis_op_ret = slp_genesis_output("ADEXSLP", "ADEXSLP", None, None, 8, None, 1000000_00000000);
        let slp_genesis = TransactionOutput {
            value: self.coin.as_ref().dust_amount,
            script_pubkey: Builder::build_p2pkh(&self.coin.my_public_key().unwrap().address_hash().into()).to_bytes(),
        };

        let mut bch_outputs = vec![slp_genesis_op_ret, slp_genesis];
        let mut slp_outputs = vec![];

        for _ in 0..18 {
            let key_pair = KeyPair::random_compressed();
            let address = AddressBuilder::new(
                Default::default(),
                Default::default(),
                self.coin.as_ref().conf.address_prefixes.clone(),
                None,
            )
            .as_pkh_from_pk(*key_pair.public())
            .build()
            .expect("valid address props");

            self.native_client()
                .import_address(&address.to_string(), &address.to_string(), false)
                .wait()
                .unwrap();

            let script_pubkey = Builder::build_p2pkh(&key_pair.public().address_hash().into());

            bch_outputs.push(TransactionOutput {
                value: 1000_00000000,
                script_pubkey: script_pubkey.to_bytes(),
            });

            slp_outputs.push(SlpOutput {
                amount: 1000_00000000,
                script_pubkey: script_pubkey.to_bytes(),
            });
            slp_privkeys.push(*key_pair.private_ref());
        }

        let slp_genesis_tx = send_outputs_from_my_address(self.coin.clone(), bch_outputs)
            .wait()
            .unwrap();
        let confirm_payment_input = ConfirmPaymentInput {
            payment_tx: slp_genesis_tx.tx_hex(),
            confirmations: 1,
            requires_nota: false,
            wait_until: wait_until_sec(30),
            check_every: 1,
        };
        self.coin.wait_for_confirmations(confirm_payment_input).wait().unwrap();

        let adex_slp = SlpToken::new(
            8,
            "ADEXSLP".into(),
            slp_genesis_tx.tx_hash_as_bytes().as_slice().into(),
            self.coin.clone(),
            1,
        )
        .unwrap();

        let tx = block_on(adex_slp.send_slp_outputs(slp_outputs)).unwrap();
        let confirm_payment_input = ConfirmPaymentInput {
            payment_tx: tx.tx_hex(),
            confirmations: 1,
            requires_nota: false,
            wait_until: wait_until_sec(30),
            check_every: 1,
        };
        self.coin.wait_for_confirmations(confirm_payment_input).wait().unwrap();
        *SLP_TOKEN_OWNERS.lock().unwrap() = slp_privkeys;
        *SLP_TOKEN_ID.lock().unwrap() = slp_genesis_tx.tx_hash_as_bytes().as_slice().into();
    }
}

impl CoinDockerOps for BchDockerOps {
    fn rpc_client(&self) -> &UtxoRpcClientEnum { &self.coin.as_ref().rpc_client }
}

pub struct DockerNode<'a> {
    #[allow(dead_code)]
    pub container: Container<'a, GenericImage>,
    #[allow(dead_code)]
    pub ticker: String,
    #[allow(dead_code)]
    pub port: u16,
}

pub fn random_secp256k1_secret() -> Secp256k1Secret {
    let priv_key = SecretKey::new(&mut rand6::thread_rng());
    Secp256k1Secret::from(*priv_key.as_ref())
}

pub fn utxo_asset_docker_node<'a>(docker: &'a Cli, ticker: &'static str, port: u16) -> DockerNode<'a> {
    let image = GenericImage::new(UTXO_ASSET_DOCKER_IMAGE, "multiarch")
        .with_volume(zcash_params_path().display().to_string(), "/root/.zcash-params")
        .with_env_var("CLIENTS", "2")
        .with_env_var("CHAIN", ticker)
        .with_env_var("TEST_ADDY", "R9imXLs1hEcU9KbFDQq2hJEEJ1P5UoekaF")
        .with_env_var("TEST_WIF", "UqqW7f766rADem9heD8vSBvvrdfJb3zg5r8du9rJxPtccjWf7RG9")
        .with_env_var(
            "TEST_PUBKEY",
            "021607076d7a2cb148d542fb9644c04ffc22d2cca752f80755a0402a24c567b17a",
        )
        .with_env_var("DAEMON_URL", "http://test:test@127.0.0.1:7000")
        .with_env_var("COIN", "Komodo")
        .with_env_var("COIN_RPC_PORT", port.to_string())
        .with_wait_for(WaitFor::message_on_stdout("config is ready"));
    let image = RunnableImage::from(image).with_mapped_port((port, port));
    let container = docker.run(image);
    let mut conf_path = coin_daemon_data_dir(ticker, true);
    std::fs::create_dir_all(&conf_path).unwrap();
    conf_path.push(format!("{}.conf", ticker));
    Command::new("docker")
        .arg("cp")
        .arg(format!("{}:/data/node_0/{}.conf", container.id(), ticker))
        .arg(&conf_path)
        .status()
        .expect("Failed to execute docker command");
    let timeout = wait_until_ms(3000);
    loop {
        if conf_path.exists() {
            break;
        };
        assert!(now_ms() < timeout, "Test timed out");
    }
    DockerNode {
        container,
        ticker: ticker.into(),
        port,
    }
}

pub fn geth_docker_node<'a>(docker: &'a Cli, ticker: &'static str, port: u16) -> DockerNode<'a> {
    let image = GenericImage::new(GETH_DOCKER_IMAGE, "stable");
    let args = vec!["--dev".into(), "--http".into(), "--http.addr=0.0.0.0".into()];
    let image = RunnableImage::from((image, args)).with_mapped_port((port, port));
    let container = docker.run(image);
    DockerNode {
        container,
        ticker: ticker.into(),
        port,
    }
}

pub fn nucleus_node(docker: &'_ Cli, runtime_dir: PathBuf) -> DockerNode<'_> {
    let nucleus_node_runtime_dir = runtime_dir.join("nucleus-testnet-data");
    assert!(nucleus_node_runtime_dir.exists());

    let image = GenericImage::new(NUCLEUS_IMAGE, "latest")
        .with_volume(nucleus_node_runtime_dir.to_str().unwrap(), "/root/.nucleus");
    let image = RunnableImage::from((image, vec![])).with_network("host");
    let container = docker.run(image);

    DockerNode {
        container,
        ticker: "NUCLEUS-TEST".to_owned(),
        port: Default::default(), // This doesn't need to be the correct value as we are using the host network.
    }
}

pub fn atom_node(docker: &'_ Cli, runtime_dir: PathBuf) -> DockerNode<'_> {
    let atom_node_runtime_dir = runtime_dir.join("atom-testnet-data");
    assert!(atom_node_runtime_dir.exists());

    let image =
        GenericImage::new(ATOM_IMAGE, "latest").with_volume(atom_node_runtime_dir.to_str().unwrap(), "/root/.gaia");
    let image = RunnableImage::from((image, vec![])).with_network("host");
    let container = docker.run(image);

    DockerNode {
        container,
        ticker: "ATOM-TEST".to_owned(),
        port: Default::default(), // This doesn't need to be the correct value as we are using the host network.
    }
}

pub fn ibc_relayer_node(docker: &'_ Cli, runtime_dir: PathBuf) -> DockerNode<'_> {
    let relayer_node_runtime_dir = runtime_dir.join("ibc-relayer-data");
    assert!(relayer_node_runtime_dir.exists());

    let image = GenericImage::new(IBC_RELAYER_IMAGE, "latest")
        .with_volume(relayer_node_runtime_dir.to_str().unwrap(), "/home/relayer/.relayer");
    let image = RunnableImage::from((image, vec![])).with_network("host");
    let container = docker.run(image);

    DockerNode {
        container,
        ticker: Default::default(), // This isn't an asset node.
        port: Default::default(),   // This doesn't need to be the correct value as we are using the host network.
    }
}

pub fn rmd160_from_priv(privkey: Secp256k1Secret) -> H160 {
    let secret = SecretKey::from_slice(privkey.as_slice()).unwrap();
    let public = PublicKey::from_secret_key(&Secp256k1::new(), &secret);
    dhash160(&public.serialize())
}

pub fn get_prefilled_slp_privkey() -> [u8; 32] { SLP_TOKEN_OWNERS.lock().unwrap().remove(0) }

pub fn get_slp_token_id() -> String { hex::encode(SLP_TOKEN_ID.lock().unwrap().as_slice()) }

pub fn import_address<T>(coin: &T)
where
    T: MarketCoinOps + AsRef<UtxoCoinFields>,
{
    let mutex = match coin.ticker() {
        "MYCOIN" => &*MY_COIN_LOCK,
        "MYCOIN1" => &*MY_COIN1_LOCK,
        "QTUM" | "QICK" | "QORTY" => &*QTUM_LOCK,
        "FORSLP" => &*FOR_SLP_LOCK,
        ticker => panic!("Unknown ticker {}", ticker),
    };
    let _lock = mutex.lock().unwrap();

    match coin.as_ref().rpc_client {
        UtxoRpcClientEnum::Native(ref native) => {
            let my_address = coin.my_address().unwrap();
            native.import_address(&my_address, &my_address, false).wait().unwrap()
        },
        UtxoRpcClientEnum::Electrum(_) => panic!("Expected NativeClient"),
    }
}

/// Build `Qrc20Coin` from ticker and privkey without filling the balance.
pub fn qrc20_coin_from_privkey(ticker: &str, priv_key: Secp256k1Secret) -> (MmArc, Qrc20Coin) {
    let (contract_address, swap_contract_address) = unsafe {
        let contract_address = match ticker {
            "QICK" => QICK_TOKEN_ADDRESS.expect("QICK_TOKEN_ADDRESS must be set already"),
            "QORTY" => QORTY_TOKEN_ADDRESS.expect("QORTY_TOKEN_ADDRESS must be set already"),
            _ => panic!("Expected QICK or QORTY ticker"),
        };
        (
            contract_address,
            QRC20_SWAP_CONTRACT_ADDRESS.expect("QRC20_SWAP_CONTRACT_ADDRESS must be set already"),
        )
    };
    let platform = "QTUM";
    let ctx = MmCtxBuilder::new().into_mm_arc();
    let confpath = unsafe { QTUM_CONF_PATH.as_ref().expect("Qtum config is not set yet") };
    let conf = json!({
        "coin":ticker,
        "decimals": 8,
        "required_confirmations":0,
        "pubtype":120,
        "p2shtype":110,
        "wiftype":128,
        "mm2":1,
        "mature_confirmations":500,
        "network":"regtest",
        "confpath": confpath,
        "dust": 72800,
    });
    let req = json!({
        "method": "enable",
        "swap_contract_address": format!("{:#02x}", swap_contract_address),
    });
    let params = Qrc20ActivationParams::from_legacy_req(&req).unwrap();

    let coin = block_on(qrc20_coin_with_priv_key(
        &ctx,
        ticker,
        platform,
        &conf,
        &params,
        priv_key,
        contract_address,
    ))
    .unwrap();

    import_address(&coin);
    (ctx, coin)
}

fn qrc20_coin_conf_item(ticker: &str) -> Json {
    let contract_address = unsafe {
        match ticker {
            "QICK" => QICK_TOKEN_ADDRESS.expect("QICK_TOKEN_ADDRESS must be set already"),
            "QORTY" => QORTY_TOKEN_ADDRESS.expect("QORTY_TOKEN_ADDRESS must be set already"),
            _ => panic!("Expected either QICK or QORTY ticker, found {}", ticker),
        }
    };
    let contract_address = format!("{:#02x}", contract_address);

    let confpath = unsafe { QTUM_CONF_PATH.as_ref().expect("Qtum config is not set yet") };
    json!({
        "coin":ticker,
        "required_confirmations":1,
        "pubtype":120,
        "p2shtype":110,
        "wiftype":128,
        "mature_confirmations":500,
        "confpath":confpath,
        "network":"regtest",
        "protocol":{"type":"QRC20","protocol_data":{"platform":"QTUM","contract_address":contract_address}}})
}

/// Build asset `UtxoStandardCoin` from ticker and privkey without filling the balance.
pub fn utxo_coin_from_privkey(ticker: &str, priv_key: Secp256k1Secret) -> (MmArc, UtxoStandardCoin) {
    let ctx = MmCtxBuilder::new().into_mm_arc();
    let conf = json!({"asset":ticker,"txversion":4,"overwintered":1,"txfee":1000,"network":"regtest"});
    let req = json!({"method":"enable"});
    let params = UtxoActivationParams::from_legacy_req(&req).unwrap();
    let coin = block_on(utxo_standard_coin_with_priv_key(&ctx, ticker, &conf, &params, priv_key)).unwrap();
    import_address(&coin);
    (ctx, coin)
}

/// Create a UTXO coin for the given privkey and fill it's address with the specified balance.
pub fn generate_utxo_coin_with_privkey(ticker: &str, balance: BigDecimal, priv_key: Secp256k1Secret) {
    let (_, coin) = utxo_coin_from_privkey(ticker, priv_key);
    let timeout = 30; // timeout if test takes more than 30 seconds to run
    let my_address = coin.my_address().expect("!my_address");
    fill_address(&coin, &my_address, balance, timeout);
}

/// Generate random privkey, create a UTXO coin and fill it's address with the specified balance.
pub fn generate_utxo_coin_with_random_privkey(
    ticker: &str,
    balance: BigDecimal,
) -> (MmArc, UtxoStandardCoin, Secp256k1Secret) {
    let priv_key = random_secp256k1_secret();
    let (ctx, coin) = utxo_coin_from_privkey(ticker, priv_key);
    let timeout = 30; // timeout if test takes more than 30 seconds to run
    let my_address = coin.my_address().expect("!my_address");
    fill_address(&coin, &my_address, balance, timeout);
    (ctx, coin, priv_key)
}

/// Get only one address assigned the specified label.
pub fn get_address_by_label<T>(coin: T, label: &str) -> String
where
    T: AsRef<UtxoCoinFields>,
{
    let native = match coin.as_ref().rpc_client {
        UtxoRpcClientEnum::Native(ref native) => native,
        UtxoRpcClientEnum::Electrum(_) => panic!("NativeClient expected"),
    };
    let mut addresses = native
        .get_addresses_by_label(label)
        .wait()
        .expect("!getaddressesbylabel")
        .into_iter();
    match addresses.next() {
        Some((addr, _purpose)) if addresses.next().is_none() => addr,
        Some(_) => panic!("Expected only one address by {:?}", label),
        None => panic!("Expected one address by {:?}", label),
    }
}

pub fn fill_qrc20_address(coin: &Qrc20Coin, amount: BigDecimal, timeout: u64) {
    // prevent concurrent fill since daemon RPC returns errors if send_to_address
    // is called concurrently (insufficient funds) and it also may return other errors
    // if previous transaction is not confirmed yet
    let _lock = QTUM_LOCK.lock().unwrap();
    let timeout = wait_until_sec(timeout);
    let client = match coin.as_ref().rpc_client {
        UtxoRpcClientEnum::Native(ref client) => client,
        UtxoRpcClientEnum::Electrum(_) => panic!("Expected NativeClient"),
    };

    let from_addr = get_address_by_label(coin, QTUM_ADDRESS_LABEL);
    let to_addr = coin.my_addr_as_contract_addr().compat().wait().unwrap();
    let satoshis = sat_from_big_decimal(&amount, coin.as_ref().decimals).expect("!sat_from_big_decimal");

    let hash = client
        .transfer_tokens(
            &coin.contract_address,
            &from_addr,
            to_addr,
            satoshis.into(),
            coin.as_ref().decimals,
        )
        .wait()
        .expect("!transfer_tokens")
        .txid;

    let tx_bytes = client.get_transaction_bytes(&hash).wait().unwrap();
    log!("{:02x}", tx_bytes);
    let confirm_payment_input = ConfirmPaymentInput {
        payment_tx: tx_bytes.0,
        confirmations: 1,
        requires_nota: false,
        wait_until: timeout,
        check_every: 1,
    };
    coin.wait_for_confirmations(confirm_payment_input).wait().unwrap();
}

/// Generate random privkey, create a QRC20 coin and fill it's address with the specified balance.
pub fn generate_qrc20_coin_with_random_privkey(
    ticker: &str,
    qtum_balance: BigDecimal,
    qrc20_balance: BigDecimal,
) -> (MmArc, Qrc20Coin, Secp256k1Secret) {
    let priv_key = random_secp256k1_secret();
    let (ctx, coin) = qrc20_coin_from_privkey(ticker, priv_key);

    let timeout = 30; // timeout if test takes more than 30 seconds to run
    let my_address = coin.my_address().expect("!my_address");
    fill_address(&coin, &my_address, qtum_balance, timeout);
    fill_qrc20_address(&coin, qrc20_balance, timeout);
    (ctx, coin, priv_key)
}

pub fn generate_qtum_coin_with_random_privkey(
    ticker: &str,
    balance: BigDecimal,
    txfee: Option<u64>,
) -> (MmArc, QtumCoin, [u8; 32]) {
    let confpath = unsafe { QTUM_CONF_PATH.as_ref().expect("Qtum config is not set yet") };
    let conf = json!({
        "coin":ticker,
        "decimals":8,
        "required_confirmations":0,
        "pubtype":120,
        "p2shtype": 110,
        "wiftype":128,
        "txfee": txfee,
        "txfee_volatility_percent":0.1,
        "mm2":1,
        "mature_confirmations":500,
        "network":"regtest",
        "confpath": confpath,
        "dust": 72800,
    });
    let req = json!({"method": "enable"});
    let priv_key = random_secp256k1_secret();
    let ctx = MmCtxBuilder::new().into_mm_arc();
    let params = UtxoActivationParams::from_legacy_req(&req).unwrap();
    let coin = block_on(qtum_coin_with_priv_key(&ctx, "QTUM", &conf, &params, priv_key)).unwrap();

    let timeout = 30; // timeout if test takes more than 30 seconds to run
    let my_address = coin.my_address().expect("!my_address");
    fill_address(&coin, &my_address, balance, timeout);
    (ctx, coin, priv_key.take())
}

pub fn generate_segwit_qtum_coin_with_random_privkey(
    ticker: &str,
    balance: BigDecimal,
    txfee: Option<u64>,
) -> (MmArc, QtumCoin, Secp256k1Secret) {
    let confpath = unsafe { QTUM_CONF_PATH.as_ref().expect("Qtum config is not set yet") };
    let conf = json!({
        "coin":ticker,
        "decimals":8,
        "required_confirmations":0,
        "pubtype":120,
        "p2shtype": 110,
        "wiftype":128,
        "segwit":true,
        "txfee": txfee,
        "txfee_volatility_percent":0.1,
        "mm2":1,
        "mature_confirmations":500,
        "network":"regtest",
        "confpath": confpath,
        "dust": 72800,
        "bech32_hrp":"qcrt",
        "address_format": {
            "format": "segwit",
        },
    });
    let req = json!({"method": "enable"});
    let priv_key = random_secp256k1_secret();
    let ctx = MmCtxBuilder::new().into_mm_arc();
    let params = UtxoActivationParams::from_legacy_req(&req).unwrap();
    let coin = block_on(qtum_coin_with_priv_key(&ctx, "QTUM", &conf, &params, priv_key)).unwrap();

    let timeout = 30; // timeout if test takes more than 30 seconds to run
    let my_address = coin.my_address().expect("!my_address");
    fill_address(&coin, &my_address, balance, timeout);
    (ctx, coin, priv_key)
}

pub fn fill_address<T>(coin: &T, address: &str, amount: BigDecimal, timeout: u64)
where
    T: MarketCoinOps + AsRef<UtxoCoinFields>,
{
    // prevent concurrent fill since daemon RPC returns errors if send_to_address
    // is called concurrently (insufficient funds) and it also may return other errors
    // if previous transaction is not confirmed yet
    let mutex = match coin.ticker() {
        "MYCOIN" => &*MY_COIN_LOCK,
        "MYCOIN1" => &*MY_COIN1_LOCK,
        "QTUM" | "QICK" | "QORTY" => &*QTUM_LOCK,
        "FORSLP" => &*FOR_SLP_LOCK,
        ticker => panic!("Unknown ticker {}", ticker),
    };
    let _lock = mutex.lock().unwrap();
    let timeout = wait_until_sec(timeout);

    if let UtxoRpcClientEnum::Native(client) = &coin.as_ref().rpc_client {
        client.import_address(address, address, false).wait().unwrap();
        let hash = client.send_to_address(address, &amount).wait().unwrap();
        let tx_bytes = client.get_transaction_bytes(&hash).wait().unwrap();
        let confirm_payment_input = ConfirmPaymentInput {
            payment_tx: tx_bytes.clone().0,
            confirmations: 1,
            requires_nota: false,
            wait_until: timeout,
            check_every: 1,
        };
        coin.wait_for_confirmations(confirm_payment_input).wait().unwrap();
        log!("{:02x}", tx_bytes);
        loop {
            let unspents = client
                .list_unspent_impl(0, std::i32::MAX, vec![address.to_string()])
                .wait()
                .unwrap();
            if !unspents.is_empty() {
                break;
            }
            assert!(now_sec() < timeout, "Test timed out");
            thread::sleep(Duration::from_secs(1));
        }
    };
}

/// Wait for the `estimatesmartfee` returns no errors.
pub fn wait_for_estimate_smart_fee(timeout: u64) -> Result<(), String> {
    enum EstimateSmartFeeState {
        Idle,
        Ok,
        NotAvailable,
    }
    lazy_static! {
        static ref LOCK: Mutex<EstimateSmartFeeState> = Mutex::new(EstimateSmartFeeState::Idle);
    }

    let state = &mut *LOCK.lock().unwrap();
    match state {
        EstimateSmartFeeState::Ok => return Ok(()),
        EstimateSmartFeeState::NotAvailable => return ERR!("estimatesmartfee not available"),
        EstimateSmartFeeState::Idle => log!("Start wait_for_estimate_smart_fee"),
    }

    let priv_key = random_secp256k1_secret();
    let (_ctx, coin) = qrc20_coin_from_privkey("QICK", priv_key);
    let timeout = wait_until_sec(timeout);
    let client = match coin.as_ref().rpc_client {
        UtxoRpcClientEnum::Native(ref client) => client,
        UtxoRpcClientEnum::Electrum(_) => panic!("Expected NativeClient"),
    };
    while now_sec() < timeout {
        if let Ok(res) = client.estimate_smart_fee(&None, 1).wait() {
            if res.errors.is_empty() {
                *state = EstimateSmartFeeState::Ok;
                return Ok(());
            }
        }
        thread::sleep(Duration::from_secs(1));
    }

    *state = EstimateSmartFeeState::NotAvailable;
    ERR!("Waited too long for estimate_smart_fee to work")
}

pub async fn enable_qrc20_native(mm: &MarketMakerIt, coin: &str) -> Json {
    let swap_contract_address =
        unsafe { QRC20_SWAP_CONTRACT_ADDRESS.expect("QRC20_SWAP_CONTRACT_ADDRESS must be set already") };

    let native = mm
        .rpc(&json! ({
            "userpass": mm.userpass,
            "method": "enable",
            "coin": coin,
            "swap_contract_address": format!("{:#02x}", swap_contract_address),
            "mm2": 1,
        }))
        .await
        .unwrap();
    assert_eq!(native.0, StatusCode::OK, "'enable' failed: {}", native.1);
    json::from_str(&native.1).unwrap()
}

pub fn trade_base_rel((base, rel): (&str, &str)) {
    /// Generate a wallet with the random private key and fill the wallet with Qtum (required by gas_fee) and specified in `ticker` coin.
    fn generate_and_fill_priv_key(ticker: &str) -> Secp256k1Secret {
        let timeout = 30; // timeout if test takes more than 30 seconds to run

        match ticker {
            "QTUM" => {
                //Segwit QTUM
                wait_for_estimate_smart_fee(timeout).expect("!wait_for_estimate_smart_fee");
                let (_ctx, _coin, priv_key) = generate_segwit_qtum_coin_with_random_privkey("QTUM", 10.into(), Some(0));

                priv_key
            },
            "QICK" | "QORTY" => {
                let priv_key = random_secp256k1_secret();
                let (_ctx, coin) = qrc20_coin_from_privkey(ticker, priv_key);
                let my_address = coin.my_address().expect("!my_address");
                fill_address(&coin, &my_address, 10.into(), timeout);
                fill_qrc20_address(&coin, 10.into(), timeout);

                priv_key
            },
            "MYCOIN" | "MYCOIN1" => {
                let priv_key = random_secp256k1_secret();
                let (_ctx, coin) = utxo_coin_from_privkey(ticker, priv_key);
                let my_address = coin.my_address().expect("!my_address");
                fill_address(&coin, &my_address, 10.into(), timeout);
                // also fill the Qtum
                let (_ctx, coin) = qrc20_coin_from_privkey("QICK", priv_key);
                let my_address = coin.my_address().expect("!my_address");
                fill_address(&coin, &my_address, 10.into(), timeout);

                priv_key
            },
            "ADEXSLP" | "FORSLP" => Secp256k1Secret::from(get_prefilled_slp_privkey()),
            "ETH" | "ERC20DEV" => {
                let priv_key = random_secp256k1_secret();
                fill_eth_erc20_with_private_key(priv_key);
                priv_key
            },
            _ => panic!("Expected either QICK or QORTY or MYCOIN or MYCOIN1, found {}", ticker),
        }
    }

    let bob_priv_key = generate_and_fill_priv_key(base);
    let alice_priv_key = generate_and_fill_priv_key(rel);

    let confpath = unsafe { QTUM_CONF_PATH.as_ref().expect("Qtum config is not set yet") };
    let coins = json! ([
        eth_dev_conf(),
        erc20_dev_conf(&erc20_contract_checksum()),
        qrc20_coin_conf_item("QICK"),
        qrc20_coin_conf_item("QORTY"),
        {"coin":"MYCOIN","asset":"MYCOIN","required_confirmations":0,"txversion":4,"overwintered":1,"txfee":1000,"protocol":{"type":"UTXO"}},
        {"coin":"MYCOIN1","asset":"MYCOIN1","required_confirmations":0,"txversion":4,"overwintered":1,"txfee":1000,"protocol":{"type":"UTXO"}},
        // TODO: check if we should fix protocol "type":"UTXO" to "QTUM" for this and other QTUM coin tests.
        // Maybe we should use a different coin for "UTXO" protocol and make new tests for "QTUM" protocol
        {"coin":"QTUM","asset":"QTUM","required_confirmations":0,"decimals":8,"pubtype":120,"p2shtype":110,"wiftype":128,"segwit":true,"txfee":0,"txfee_volatility_percent":0.1,
        "mm2":1,"network":"regtest","confpath":confpath,"protocol":{"type":"UTXO"},"bech32_hrp":"qcrt","address_format":{"format":"segwit"}},
        {"coin":"FORSLP","asset":"FORSLP","required_confirmations":0,"txversion":4,"overwintered":1,"txfee":1000,"protocol":{"type":"BCH","protocol_data":{"slp_prefix":"slptest"}}},
        {"coin":"ADEXSLP","protocol":{"type":"SLPTOKEN","protocol_data":{"decimals":8,"token_id":get_slp_token_id(),"platform":"FORSLP"}}}
    ]);
    let mut mm_bob = MarketMakerIt::start(
        json! ({
            "gui": "nogui",
            "netid": 9000,
            "dht": "on",  // Enable DHT without delay.
            "passphrase": format!("0x{}", hex::encode(bob_priv_key)),
            "coins": coins,
            "rpc_password": "pass",
            "i_am_seed": true,
        }),
        "pass".to_string(),
        None,
    )
    .unwrap();
    let (_bob_dump_log, _bob_dump_dashboard) = mm_dump(&mm_bob.log_path);
    block_on(mm_bob.wait_for_log(22., |log| log.contains(">>>>>>>>> DEX stats "))).unwrap();

    let mut mm_alice = MarketMakerIt::start(
        json! ({
            "gui": "nogui",
            "netid": 9000,
            "dht": "on",  // Enable DHT without delay.
            "passphrase": format!("0x{}", hex::encode(alice_priv_key)),
            "coins": coins,
            "rpc_password": "pass",
            "seednodes": vec![format!("{}", mm_bob.ip)],
        }),
        "pass".to_string(),
        None,
    )
    .unwrap();
    let (_alice_dump_log, _alice_dump_dashboard) = mm_dump(&mm_alice.log_path);
    block_on(mm_alice.wait_for_log(22., |log| log.contains(">>>>>>>>> DEX stats "))).unwrap();

    let swap_contract = format!("0x{}", hex::encode(swap_contract()));
    log!("{:?}", block_on(enable_qrc20_native(&mm_bob, "QICK")));
    log!("{:?}", block_on(enable_qrc20_native(&mm_bob, "QORTY")));
    log!("{:?}", block_on(enable_native(&mm_bob, "MYCOIN", &[], None)));
    log!("{:?}", block_on(enable_native(&mm_bob, "MYCOIN1", &[], None)));
    log!("{:?}", block_on(enable_native(&mm_bob, "QTUM", &[], None)));
    log!("{:?}", block_on(enable_native_bch(&mm_bob, "FORSLP", &[])));
    log!("{:?}", block_on(enable_native(&mm_bob, "ADEXSLP", &[], None)));
    log!(
        "{:?}",
        block_on(enable_eth_coin(
            &mm_bob,
            "ETH",
            &[GETH_RPC_URL],
            &swap_contract,
            None,
            false
        ))
    );
    log!(
        "{:?}",
        block_on(enable_eth_coin(
            &mm_bob,
            "ERC20DEV",
            &[GETH_RPC_URL],
            &swap_contract,
            None,
            false
        ))
    );

    log!("{:?}", block_on(enable_qrc20_native(&mm_alice, "QICK")));
    log!("{:?}", block_on(enable_qrc20_native(&mm_alice, "QORTY")));
    log!("{:?}", block_on(enable_native(&mm_alice, "MYCOIN", &[], None)));
    log!("{:?}", block_on(enable_native(&mm_alice, "MYCOIN1", &[], None)));
    log!("{:?}", block_on(enable_native(&mm_alice, "QTUM", &[], None)));
    log!("{:?}", block_on(enable_native_bch(&mm_alice, "FORSLP", &[])));
    log!("{:?}", block_on(enable_native(&mm_alice, "ADEXSLP", &[], None)));
    log!(
        "{:?}",
        block_on(enable_eth_coin(
            &mm_alice,
            "ETH",
            &[GETH_RPC_URL],
            &swap_contract,
            None,
            false
        ))
    );
    log!(
        "{:?}",
        block_on(enable_eth_coin(
            &mm_alice,
            "ERC20DEV",
            &[GETH_RPC_URL],
            &swap_contract,
            None,
            false
        ))
    );

    let rc = block_on(mm_bob.rpc(&json! ({
        "userpass": mm_bob.userpass,
        "method": "setprice",
        "base": base,
        "rel": rel,
        "price": 1,
        "volume": "3",
    })))
    .unwrap();
    assert!(rc.0.is_success(), "!setprice: {}", rc.1);

    thread::sleep(Duration::from_secs(1));

    log!("Issue alice {}/{} buy request", base, rel);
    let rc = block_on(mm_alice.rpc(&json! ({
        "userpass": mm_alice.userpass,
        "method": "buy",
        "base": base,
        "rel": rel,
        "price": 1,
        "volume": "2",
    })))
    .unwrap();
    assert!(rc.0.is_success(), "!buy: {}", rc.1);
    let buy_json: Json = serde_json::from_str(&rc.1).unwrap();
    let uuid = buy_json["result"]["uuid"].as_str().unwrap().to_owned();

    // ensure the swaps are started
    block_on(mm_bob.wait_for_log(22., |log| {
        log.contains(&format!("Entering the maker_swap_loop {}/{}", base, rel))
    }))
    .unwrap();
    block_on(mm_alice.wait_for_log(22., |log| {
        log.contains(&format!("Entering the taker_swap_loop {}/{}", base, rel))
    }))
    .unwrap();

    // ensure the swaps are finished
    block_on(mm_bob.wait_for_log(600., |log| log.contains(&format!("[swap uuid={}] Finished", uuid)))).unwrap();
    block_on(mm_alice.wait_for_log(600., |log| log.contains(&format!("[swap uuid={}] Finished", uuid)))).unwrap();

    log!("Checking alice/taker status..");
    block_on(check_my_swap_status(
        &mm_alice,
        &uuid,
        "2".parse().unwrap(),
        "2".parse().unwrap(),
    ));

    log!("Checking bob/maker status..");
    block_on(check_my_swap_status(
        &mm_bob,
        &uuid,
        "2".parse().unwrap(),
        "2".parse().unwrap(),
    ));

    log!("Checking alice status..");
    block_on(wait_check_stats_swap_status(&mm_alice, &uuid, 30));

    log!("Checking bob status..");
    block_on(wait_check_stats_swap_status(&mm_bob, &uuid, 30));

    log!("Checking alice recent swaps..");
    block_on(check_recent_swaps(&mm_alice, 1));
    log!("Checking bob recent swaps..");
    block_on(check_recent_swaps(&mm_bob, 1));

    block_on(mm_bob.stop()).unwrap();
    block_on(mm_alice.stop()).unwrap();
}

pub fn slp_supplied_node() -> MarketMakerIt {
    let coins = json! ([
        {"coin":"FORSLP","asset":"FORSLP","required_confirmations":0,"txversion":4,"overwintered":1,"txfee":1000,"protocol":{"type":"BCH","protocol_data":{"slp_prefix":"slptest"}}},
        {"coin":"ADEXSLP","protocol":{"type":"SLPTOKEN","protocol_data":{"decimals":8,"token_id":get_slp_token_id(),"platform":"FORSLP"}}}
    ]);

    let priv_key = get_prefilled_slp_privkey();
    MarketMakerIt::start(
        json! ({
            "gui": "nogui",
            "netid": 9000,
            "dht": "on",  // Enable DHT without delay.
            "passphrase": format!("0x{}", hex::encode(priv_key)),
            "coins": coins,
            "rpc_password": "pass",
            "i_am_seed": true,
        }),
        "pass".to_string(),
        None,
    )
    .unwrap()
}

pub fn _solana_supplied_node() -> MarketMakerIt {
    let coins = json! ([
        {"coin": "SOL-DEVNET","name": "solana","fname": "Solana","rpcport": 80,"mm2": 1,"required_confirmations": 1,"avg_blocktime": 0.25,"protocol": {"type": "SOLANA"}},
        {"coin":"USDC-SOL-DEVNET","protocol":{"type":"SPLTOKEN","protocol_data":{"decimals":6,"token_contract_address":"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU","platform":"SOL-DEVNET"}},"mm2": 1},
        {"coin":"ADEX-SOL-DEVNET","protocol":{"type":"SPLTOKEN","protocol_data":{"decimals":9,"token_contract_address":"5tSm6PqMosy1rz1AqV3kD28yYT5XqZW3QYmZommuFiPJ","platform":"SOL-DEVNET"}},"mm2": 1},
    ]);

    MarketMakerIt::start(
        json! ({
            "gui": "nogui",
            "netid": 9000,
            "dht": "on",  // Enable DHT without delay.
            "passphrase": "federal stay trigger hour exist success game vapor become comfort action phone bright ill target wild nasty crumble dune close rare fabric hen iron",
            "coins": coins,
            "rpc_password": "pass",
            "i_am_seed": true,
        }),
        "pass".to_string(),
        None,
    )
    .unwrap()
}

pub fn get_balance(mm: &MarketMakerIt, coin: &str) -> BalanceResponse {
    let rc = block_on(mm.rpc(&json!({
        "userpass": mm.userpass,
        "method": "my_balance",
        "coin": coin,
    })))
    .unwrap();
    assert_eq!(rc.0, StatusCode::OK, "my_balance request failed {}", rc.1);
    json::from_str(&rc.1).unwrap()
}

pub fn utxo_burn_address() -> Address {
    AddressBuilder::new(
        UtxoAddressFormat::Standard,
        ChecksumType::DSHA256,
        NetworkAddressPrefixes {
            p2pkh: [60].into(),
            p2sh: AddressPrefix::default(),
        },
        None,
    )
    .as_pkh(AddressHashEnum::default_address_hash())
    .build()
    .expect("valid address props")
}

pub fn withdraw_max_and_send_v1(mm: &MarketMakerIt, coin: &str, to: &str) -> TransactionDetails {
    let rc = block_on(mm.rpc(&json!({
        "userpass": mm.userpass,
        "method": "withdraw",
        "coin": coin,
        "max": true,
        "to": to,
    })))
    .unwrap();
    assert_eq!(rc.0, StatusCode::OK, "withdraw request failed {}", rc.1);
    let tx_details: TransactionDetails = json::from_str(&rc.1).unwrap();

    let rc = block_on(mm.rpc(&json!({
        "userpass": mm.userpass,
        "method": "send_raw_transaction",
        "tx_hex": tx_details.tx_hex,
        "coin": coin,
    })))
    .unwrap();
    assert_eq!(rc.0, StatusCode::OK, "send_raw_transaction request failed {}", rc.1);

    tx_details
}

async fn get_current_gas_limit(web3: &Web3<Http>) {
    match web3.eth().block(BlockId::Number(BlockNumber::Latest)).await {
        Ok(Some(block)) => {
            log!("Current gas limit: {}", block.gas_limit);
        },
        Ok(None) => log!("Latest block information is not available."),
        Err(e) => log!("Failed to fetch the latest block: {}", e),
    }
}

pub fn wait_until_relayer_container_is_ready(container_id: &str) {
    const Q_RESULT: &str = "0: nucleus-atom         -> chns(✔) clnts(✔) conn(✔) (nucleus-testnet<>cosmoshub-testnet)";

    let mut attempts = 0;
    loop {
        let mut docker = Command::new("docker");
        docker.arg("exec").arg(container_id).args(["rly", "paths", "list"]);

        log!("Running <<{docker:?}>>.");

        let output = docker.stderr(Stdio::inherit()).output().unwrap();
        let output = String::from_utf8(output.stdout).unwrap();
        let output = output.trim();

        if output == Q_RESULT {
            break;
        }
        attempts += 1;

        log!("Expected output {Q_RESULT}, received {output}.");
        if attempts > 10 {
            panic!("{}", "Reached max attempts for <<{docker:?}>>.");
        } else {
            log!("Asking for relayer node status again..");
        }

        thread::sleep(Duration::from_secs(2));
    }
}

pub fn init_geth_node() {
    unsafe {
        block_on(get_current_gas_limit(&GETH_WEB3));
        let gas_price = block_on(GETH_WEB3.eth().gas_price()).unwrap();
        log!("Current gas price: {:?}", gas_price);
        let accounts = block_on(GETH_WEB3.eth().accounts()).unwrap();
        GETH_ACCOUNT = accounts[0];
        log!("GETH ACCOUNT {:?}", GETH_ACCOUNT);

        let tx_request_deploy_erc20 = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(ERC20_TOKEN_BYTES).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };

        let deploy_erc20_tx_hash = block_on(GETH_WEB3.eth().send_transaction(tx_request_deploy_erc20)).unwrap();
        log!("Sent ERC20 deploy transaction {:?}", deploy_erc20_tx_hash);

        loop {
            let deploy_tx_receipt = match block_on(GETH_WEB3.eth().transaction_receipt(deploy_erc20_tx_hash)) {
                Ok(receipt) => receipt,
                Err(_) => {
                    thread::sleep(Duration::from_millis(100));
                    continue;
                },
            };

            if let Some(receipt) = deploy_tx_receipt {
                GETH_ERC20_CONTRACT = receipt.contract_address.unwrap();
                log!("GETH_ERC20_CONTRACT {:?}", GETH_ERC20_CONTRACT);
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let tx_request_deploy_swap_contract = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(SWAP_CONTRACT_BYTES).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_swap_tx_hash = block_on(GETH_WEB3.eth().send_transaction(tx_request_deploy_swap_contract)).unwrap();
        log!("Sent deploy swap contract transaction {:?}", deploy_swap_tx_hash);

        loop {
            let deploy_swap_tx_receipt = match block_on(GETH_WEB3.eth().transaction_receipt(deploy_swap_tx_hash)) {
                Ok(receipt) => receipt,
                Err(_) => {
                    thread::sleep(Duration::from_millis(100));
                    continue;
                },
            };

            if let Some(receipt) = deploy_swap_tx_receipt {
                GETH_SWAP_CONTRACT = receipt.contract_address.unwrap();
                log!("GETH_SWAP_CONTRACT {:?}", GETH_SWAP_CONTRACT);
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let tx_request_deploy_maker_swap_contract_v2 = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(MAKER_SWAP_V2_BYTES).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_maker_swap_v2_tx_hash = block_on(
            GETH_WEB3
                .eth()
                .send_transaction(tx_request_deploy_maker_swap_contract_v2),
        )
        .unwrap();
        log!(
            "Sent deploy maker swap v2 contract transaction {:?}",
            deploy_maker_swap_v2_tx_hash
        );

        loop {
            let deploy_maker_swap_v2_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_maker_swap_v2_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_maker_swap_v2_tx_receipt {
                GETH_MAKER_SWAP_V2 = receipt.contract_address.unwrap();
                log!(
                    "GETH_MAKER_SWAP_V2 contract address: {:?}, receipt.status: {:?}",
                    GETH_MAKER_SWAP_V2,
                    receipt.status
                );
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let dex_fee_addr = addr_from_raw_pubkey(&DEX_FEE_ADDR_RAW_PUBKEY).unwrap();
        let dex_fee_addr = Token::Address(dex_fee_addr);
        let params = ethabi::encode(&[dex_fee_addr]);
        let taker_swap_v2_data = format!("{}{}", TAKER_SWAP_V2_BYTES, hex::encode(params));

        let tx_request_deploy_taker_swap_contract_v2 = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(taker_swap_v2_data).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_taker_swap_v2_tx_hash = block_on(
            GETH_WEB3
                .eth()
                .send_transaction(tx_request_deploy_taker_swap_contract_v2),
        )
        .unwrap();
        log!(
            "Sent deploy taker swap v2 contract transaction {:?}",
            deploy_taker_swap_v2_tx_hash
        );

        loop {
            let deploy_taker_swap_v2_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_taker_swap_v2_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_taker_swap_v2_tx_receipt {
                GETH_TAKER_SWAP_V2 = receipt.contract_address.unwrap();
                log!(
                    "GETH_TAKER_SWAP_V2 contract address: {:?}, receipt.status: {:?}",
                    GETH_TAKER_SWAP_V2,
                    receipt.status
                );
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let tx_request_deploy_watchers_swap_contract = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(WATCHERS_SWAP_CONTRACT_BYTES).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_watchers_swap_tx_hash = block_on(
            GETH_WEB3
                .eth()
                .send_transaction(tx_request_deploy_watchers_swap_contract),
        )
        .unwrap();
        log!(
            "Sent deploy watchers swap contract transaction {:?}",
            deploy_watchers_swap_tx_hash
        );

        loop {
            let deploy_watchers_swap_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_watchers_swap_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_watchers_swap_tx_receipt {
                GETH_WATCHERS_SWAP_CONTRACT = receipt.contract_address.unwrap();
                log!("GETH_WATCHERS_SWAP_CONTRACT {:?}", GETH_WATCHERS_SWAP_CONTRACT);
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let tx_request_deploy_nft_maker_swap_v2_contract = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(NFT_MAKER_SWAP_V2_BYTES).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_nft_maker_swap_v2_tx_hash = block_on(
            GETH_WEB3
                .eth()
                .send_transaction(tx_request_deploy_nft_maker_swap_v2_contract),
        )
        .unwrap();
        log!(
            "Sent deploy nft maker swap v2 contract transaction {:?}",
            deploy_nft_maker_swap_v2_tx_hash
        );

        loop {
            let deploy_nft_maker_swap_v2_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_nft_maker_swap_v2_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_nft_maker_swap_v2_tx_receipt {
                GETH_NFT_MAKER_SWAP_V2 = receipt.contract_address.unwrap();
                log!(
                    "GETH_NFT_MAKER_SWAP_V2 contact address: {:?}, receipt.status: {:?}",
                    GETH_NFT_MAKER_SWAP_V2,
                    receipt.status
                );
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let dex_fee_address = Token::Address(geth_account());
        let params = ethabi::encode(&[dex_fee_address]);
        let nft_swap_data = format!("{}{}", NFT_SWAP_CONTRACT_BYTES, hex::encode(params));

        let tx_request_deploy_nft_swap_contract = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(nft_swap_data).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_nft_swap_tx_hash =
            block_on(GETH_WEB3.eth().send_transaction(tx_request_deploy_nft_swap_contract)).unwrap();
        log!("Sent deploy nft swap contract transaction {:?}", deploy_swap_tx_hash);

        loop {
            let deploy_nft_swap_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_nft_swap_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_nft_swap_tx_receipt {
                GETH_NFT_SWAP_CONTRACT = receipt.contract_address.unwrap();
                log!(
                    "GETH_NFT_SWAP_CONTRACT {:?}, receipt.status {:?}",
                    GETH_NFT_SWAP_CONTRACT,
                    receipt.status
                );
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let tx_request_deploy_nft_maker_swap_v2_contract = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(NFT_MAKER_SWAP_V2_BYTES).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_nft_maker_swap_v2_tx_hash = block_on(
            GETH_WEB3
                .eth()
                .send_transaction(tx_request_deploy_nft_maker_swap_v2_contract),
        )
        .unwrap();
        log!(
            "Sent deploy nft maker swap v2 contract transaction {:?}",
            deploy_nft_maker_swap_v2_tx_hash
        );

        loop {
            let deploy_nft_maker_swap_v2_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_nft_maker_swap_v2_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_nft_maker_swap_v2_tx_receipt {
                GETH_NFT_MAKER_SWAP_V2 = receipt.contract_address.unwrap();
                log!(
                    "GETH_NFT_MAKER_SWAP_V2 {:?}, receipt.status {:?}",
                    GETH_NFT_MAKER_SWAP_V2,
                    receipt.status
                );
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let dex_fee_address = Token::Address(geth_account());
        let params = ethabi::encode(&[dex_fee_address]);
        let nft_swap_data = format!("{}{}", NFT_SWAP_CONTRACT_BYTES, hex::encode(params));

        let tx_request_deploy_nft_swap_contract = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(nft_swap_data).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_nft_swap_tx_hash =
            block_on(GETH_WEB3.eth().send_transaction(tx_request_deploy_nft_swap_contract)).unwrap();
        log!("Sent deploy nft swap contract transaction {:?}", deploy_swap_tx_hash);

        loop {
            let deploy_nft_swap_tx_receipt =
                match block_on(GETH_WEB3.eth().transaction_receipt(deploy_nft_swap_tx_hash)) {
                    Ok(receipt) => receipt,
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                        continue;
                    },
                };

            if let Some(receipt) = deploy_nft_swap_tx_receipt {
                GETH_NFT_SWAP_CONTRACT = receipt.contract_address.unwrap();
                log!(
                    "GETH_NFT_SWAP_CONTRACT {:?}, receipt.status {:?}",
                    GETH_NFT_SWAP_CONTRACT,
                    receipt.status
                );
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let name = Token::String("MyNFT".into());
        let symbol = Token::String("MNFT".into());
        let params = ethabi::encode(&[name, symbol]);
        let erc721_data = format!("{}{}", ERC721_TEST_TOKEN_BYTES, hex::encode(params));

        let tx_request_deploy_erc721 = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(erc721_data).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_erc721_tx_hash = block_on(GETH_WEB3.eth().send_transaction(tx_request_deploy_erc721)).unwrap();
        log!("Sent ERC721 deploy transaction {:?}", deploy_erc721_tx_hash);

        loop {
            let deploy_erc721_tx_receipt = match block_on(GETH_WEB3.eth().transaction_receipt(deploy_erc721_tx_hash)) {
                Ok(receipt) => receipt,
                Err(_) => {
                    thread::sleep(Duration::from_millis(100));
                    continue;
                },
            };

            if let Some(receipt) = deploy_erc721_tx_receipt {
                GETH_ERC721_CONTRACT = receipt.contract_address.unwrap();
                log!("GETH_ERC721_CONTRACT {:?}", GETH_ERC721_CONTRACT);
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        let uri = Token::String("MyNFTUri".into());
        let params = ethabi::encode(&[uri]);
        let erc1155_data = format!("{}{}", ERC1155_TEST_TOKEN_BYTES, hex::encode(params));

        let tx_request_deploy_erc1155 = TransactionRequest {
            from: GETH_ACCOUNT,
            to: None,
            gas: None,
            gas_price: None,
            value: None,
            data: Some(hex::decode(erc1155_data).unwrap().into()),
            nonce: None,
            condition: None,
            transaction_type: None,
            access_list: None,
            max_fee_per_gas: None,
            max_priority_fee_per_gas: None,
        };
        let deploy_erc1155_tx_hash = block_on(GETH_WEB3.eth().send_transaction(tx_request_deploy_erc1155)).unwrap();
        log!("Sent ERC1155 deploy transaction {:?}", deploy_erc721_tx_hash);

        loop {
            let deploy_erc1155_tx_receipt = match block_on(GETH_WEB3.eth().transaction_receipt(deploy_erc1155_tx_hash))
            {
                Ok(receipt) => receipt,
                Err(_) => {
                    thread::sleep(Duration::from_millis(100));
                    continue;
                },
            };

            if let Some(receipt) = deploy_erc1155_tx_receipt {
                GETH_ERC1155_CONTRACT = receipt.contract_address.unwrap();
                log!("GETH_ERC1155_CONTRACT {:?}", GETH_ERC1155_CONTRACT);
                break;
            }
            thread::sleep(Duration::from_millis(100));
        }

        SEPOLIA_ETOMIC_MAKER_NFT_SWAP_V2 = EthAddress::from_str("0x9eb88cd58605d8fb9b14652d6152727f7e95fb4d").unwrap();
        SEPOLIA_ERC721_CONTRACT = EthAddress::from_str("0xbac1c9f2087f39caaa4e93412c6412809186870e").unwrap();
        SEPOLIA_ERC1155_CONTRACT = EthAddress::from_str("0xfb53b8764be6033d89ceacafa36631b09d60a1d2").unwrap();

        let alice_passphrase = get_passphrase!(".env.client", "ALICE_PASSPHRASE").unwrap();
        let alice_keypair = key_pair_from_seed(&alice_passphrase).unwrap();
        let alice_eth_addr = addr_from_raw_pubkey(alice_keypair.public()).unwrap();
        // 100 ETH
        fill_eth(alice_eth_addr, U256::from(10).pow(U256::from(20)));

        let bob_passphrase = get_passphrase!(".env.seed", "BOB_PASSPHRASE").unwrap();
        let bob_keypair = key_pair_from_seed(&bob_passphrase).unwrap();
        let bob_eth_addr = addr_from_raw_pubkey(bob_keypair.public()).unwrap();
        // 100 ETH
        fill_eth(bob_eth_addr, U256::from(10).pow(U256::from(20)));
    }
}
